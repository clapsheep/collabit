## 1주차

### 250113
우리 프로젝트에서 MyBatis와 JPA 중 어떤 것을 사용할지 고민하면서 둘의 특징 및 장단점을 공부했다. MyBatis는 개발자가 직접 SQL 쿼리를 작성할 수 있어 복잡한 쿼리나 다이나믹 쿼리가 많이 사용되는 프로젝트에서 사용하면 좋다. JPA는 ORM 프레임워크를 사용할 수 있게 도와주는 API로 개발자가 SQL문을 직접 작성하지 않아도 객체와 데이터베이스 간의 변환을 자동 처리해준다. 더하여 JPA에서 자동으로 적합한 SQL을 만들어줘서 DB가 변경되어도 SQL을 다시 작성할 필요가 없다.
우리 프로젝트는 다이나믹 쿼리가 많지 않기도 하고 후에 DB 마이그레이션을 생각하여 JPA를 선택하였다.

### 250114
DB도 프로젝트에 적합한 것을 찾기 위해 공부했다. MySQL, MariaDB, PostgreSQL, Oracle 정도 생각했는데 PostgreSQL는 문법이 달라서, Oracle은 비용 부담 때문에 제외했다. MySQL, MariaDB 중에 고민하다가 MySQL이 호환이 좋아서 후에 DB 마이그레이션을 생각해 MySQL을 선택하였다.

### 250115
프로젝트 ERD를 설계하였는데 정규화를 진행하냐, 반정규화를 하냐 고민을 하면서 그렇게 설계 했을 때 각각이 가지는 이점을 생각할 수 있었다. 또, NoSQL에 어떤 데이터를 저장하면 좋을지 고민하고 저장 구조나 쿼리문에 대해 간단히 알아봤다. Redis가 무엇인지 알아보고, 어떤 기능을 구현할 때 사용하면 좋을지 논의했다.

### 250116
기능을 수정하며 ERD 설계도 수정하게 되었다. DB에 정보를 조금 더 저장하더라도 페이지가 로드 될 때마다 해당 데이터를 조회하며 발생하는 조인, DB 접근 횟수를 줄이는 방법과 중복데이터를 최소화하지만 DB에 자주 접근하는 방식 중 어떤 것이 이득인지 고민하는 시간을 가졌다. 배포를 생각하고 있는 상황에서 지원되는 자원이 한정적이라 중복데이터를 줄여 공간적인 이득을 보는 것이 우리 프로젝트에 더 중요할 것 같다는 판단을 하였다. 더하여 프론트에서 리액트 쿼리를 사용하여 해당 정보는 1번만 불러와 캐싱 작업을 해도 된다는 정보를 듣고 중복데이터를 줄이는 방향으로 생각을 굳히게 되었다.

### 250117
NoSQL에 어떤 데이터를 저장할지 고민하고 ERD 설계 마무리 작업을 했다.
협업 능력을 조사하기 위해서 필요한 지표를 찾고 문항을 만들며 설문조사 문항을 확정지었다.
유저 플로우 및 경쟁서비스와 차별성을 문서화하여 기획적인 부분을 마무리하였다.

---

## 2주차

### 250120
OAuth2.0의 기본 동작 원리를 공부하고 깃허브 소셜 로그인을 할 경우 우리 서비스에서 JWT 토큰을 어떻게 발급해줄지 고민하였다.
GitHub 소셜 로그인 + JWT 토큰 발급 플로우
1. 사용자 인증 요청
- 클라이언트에서 "GitHub 로그인" 버튼 클릭
- 사용자를 GitHub 인증 페이지로 리다이렉트 (요청 URL에 client_id, redirect_uri, scope 등을 포함)
2. 사용자 승인
- 사용자가 자신의 GitHub 계정을 통해 권한 부여 동의
- GitHub는 사용자가 동의한 경우 Authorization Code를 발급하여 redirect_uri로 전달
3. Access Token 요청
- 클라이언트는 받은 Authorization Code를 백엔드에 전달
- 백엔드는 GitHub의 Authorization Code를 사용해 Access Token 요청. (요청 시 client_id, client_secret, redirect_uri, code 등 포함)
4. Access Token 발급
- GitHub는 유효한 요청임을 확인 후 Access Token 발급
- 백엔드는 Access Token을 사용해 GitHub의 User Info API를 호출하여 사용자 정보를 가져옴
5. JWT 토큰 생성
- 백엔드는 GitHub에서 가져온 사용자 정보를 기반으로 서비스에서 사용할 사용자 정보를 가공 (예: id, name, email, avatar_url 등)
- 가공된 정보를 바탕으로 JWT Access Token을 생성 (필요 시 Refresh Token도 생성)
- JWT에는 사용자 식별 정보와 함께 만료 시간 등 보안 정보를 포함
6. JWT 토큰 반환
- 백엔드는 생성한 JWT Access Token (및 Refresh Token)을 클라이언트에 응답으로 전달


