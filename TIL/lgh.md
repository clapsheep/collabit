## 1주차

### 250113
우리 프로젝트에서 MyBatis와 JPA 중 어떤 것을 사용할지 고민하면서 둘의 특징 및 장단점을 공부했다. MyBatis는 개발자가 직접 SQL 쿼리를 작성할 수 있어 복잡한 쿼리나 다이나믹 쿼리가 많이 사용되는 프로젝트에서 사용하면 좋다. JPA는 ORM 프레임워크를 사용할 수 있게 도와주는 API로 개발자가 SQL문을 직접 작성하지 않아도 객체와 데이터베이스 간의 변환을 자동 처리해준다. 더하여 JPA에서 자동으로 적합한 SQL을 만들어줘서 DB가 변경되어도 SQL을 다시 작성할 필요가 없다.
우리 프로젝트는 다이나믹 쿼리가 많지 않기도 하고 후에 DB 마이그레이션을 생각하여 JPA를 선택하였다.

### 250114
DB도 프로젝트에 적합한 것을 찾기 위해 공부했다. MySQL, MariaDB, PostgreSQL, Oracle 정도 생각했는데 PostgreSQL는 문법이 달라서, Oracle은 비용 부담 때문에 제외했다. MySQL, MariaDB 중에 고민하다가 MySQL이 호환이 좋아서 후에 DB 마이그레이션을 생각해 MySQL을 선택하였다.

### 250115
프로젝트 ERD를 설계하였는데 정규화를 진행하냐, 반정규화를 하냐 고민을 하면서 그렇게 설계 했을 때 각각이 가지는 이점을 생각할 수 있었다. 또, NoSQL에 어떤 데이터를 저장하면 좋을지 고민하고 저장 구조나 쿼리문에 대해 간단히 알아봤다. Redis가 무엇인지 알아보고, 어떤 기능을 구현할 때 사용하면 좋을지 논의했다.

### 250116
기능을 수정하며 ERD 설계도 수정하게 되었다. DB에 정보를 조금 더 저장하더라도 페이지가 로드 될 때마다 해당 데이터를 조회하며 발생하는 조인, DB 접근 횟수를 줄이는 방법과 중복데이터를 최소화하지만 DB에 자주 접근하는 방식 중 어떤 것이 이득인지 고민하는 시간을 가졌다. 배포를 생각하고 있는 상황에서 지원되는 자원이 한정적이라 중복데이터를 줄여 공간적인 이득을 보는 것이 우리 프로젝트에 더 중요할 것 같다는 판단을 하였다. 더하여 프론트에서 리액트 쿼리를 사용하여 해당 정보는 1번만 불러와 캐싱 작업을 해도 된다는 정보를 듣고 중복데이터를 줄이는 방향으로 생각을 굳히게 되었다.

### 250117
NoSQL에 어떤 데이터를 저장할지 고민하고 ERD 설계 마무리 작업을 했다.
협업 능력을 조사하기 위해서 필요한 지표를 찾고 문항을 만들며 설문조사 문항을 확정지었다.
유저 플로우 및 경쟁서비스와 차별성을 문서화하여 기획적인 부분을 마무리하였다.

---

## 2주차

### 250120
OAuth2.0의 기본 동작 원리를 공부하고 깃허브 소셜 로그인을 할 경우 우리 서비스에서 JWT 토큰을 어떻게 발급해줄지 고민하였다.

GitHub 소셜 로그인 + JWT 토큰 발급 플로우
1. 사용자 인증 요청
- 클라이언트에서 "GitHub 로그인" 버튼 클릭
- 사용자를 GitHub 인증 페이지로 리다이렉트 (요청 URL에 client_id, redirect_uri, scope 등을 포함)
2. 사용자 승인
- 사용자가 자신의 GitHub 계정을 통해 권한 부여 동의
- GitHub는 사용자가 동의한 경우 Authorization Code를 발급하여 redirect_uri로 전달
3. Access Token 요청
- 클라이언트는 받은 Authorization Code를 백엔드에 전달
- 백엔드는 GitHub의 Authorization Code를 사용해 Access Token 요청. (요청 시 client_id, client_secret, redirect_uri, code 등 포함)
4. Access Token 발급
- GitHub는 유효한 요청임을 확인 후 Access Token 발급
- 백엔드는 Access Token을 사용해 GitHub의 User Info API를 호출하여 사용자 정보를 가져옴
5. JWT 토큰 생성
- 백엔드는 GitHub에서 가져온 사용자 정보를 기반으로 서비스에서 사용할 사용자 정보를 가공 (예: id, name, email, avatar_url 등)
- 가공된 정보를 바탕으로 JWT Access Token을 생성 (필요 시 Refresh Token도 생성)
- JWT에는 사용자 식별 정보와 함께 만료 시간 등 보안 정보를 포함
6. JWT 토큰 반환
- 백엔드는 생성한 JWT Access Token (및 Refresh Token)을 클라이언트에 응답으로 전달

### 250121
- User Entity 생성 및 테스트

Lombok이 생성하는 빌더 클래스는 파라미터로 선언된 필드만 다룬다.
그래서 생성자의 파라미터가 아닌 내부 로직 (this.code = UUID.randomUUID().toString(), this.id = null, this.password = null)은 실행되지 않는다.
우리 프로젝트에서 code는 PK이므로 값이 꼭 존재해야하는데 UUID를 생성하는 로직이 실행되지 않아서 빈 값이 가고 거기서 계속 오류가 발생했다.

- 해결 방법
1. 정적 팩토리 메소드 사용
정적 메소드는 사용자 회원가입을 하는데 사용하면 안될 것 같아서 기각.

2. @Builder.Default 사용
해당 어노테이션이 붙은 필드는 빌더 패턴을 사용할 때도 지정된 기본값을 사용한다.
즉, 생성자에서 수행하지 않고 code의 선언에 @Builder.Default를 붙여 객체를 생성할 때마다 새로운 UUID가 자동으로 생성되도록 한다.
하지만 해당 어노테이션을 필드 레벨에서 사용하려면 클래스 레벨에 @Builder이 필요하게 되어 2가지 다른 생성자를 위한 빌드 패턴을 사용할 수 없게 된다.
```
@Id
@Builder.Default
@Column(name = "code")
private String code = UUID.randomUUID().toString();
```
3. final 키워드 사용
Java에서 final 필드의 초기화는 필드 선언 시 직접 초기화 or 생성자에서 초기화 중 하나의 시점에서 반드시 1번만 수행된다. (final 키워드가 있으면 값 변경이 불가능하기 때문)
code도 값이 변경되지 않고 객체마다 고유해야하므로 필드 선언 시 직접 초기화를 하여, 새로운 User 객체가 생성될 때마다 해당 코드가 실행되어 새로운 UUID가 생성되도록 하였다.
```
@Id
@Column(name = "code")
private final String code = UUID.randomUUID().toString();
```
=> code를 생성자에서 초기화 하지 않고 따로 관리하여 생성자는 Lombok builder를 사용하여 쉽게 처리할 수 있게 하였다.

### 250122
@Transactional 사용
붙였을 때:
데이터베이스 작업이 하나의 트랜잭션으로 처리됨
메소드 실행 중 에러 발생 시 모든 DB 변경사항이 롤백됨
DB 일관성과 데이터 무결성 보장

안 붙였을 때:
각 DB 작업이 개별적으로 처리됨
일부 작업이 실패해도 이전 작업은 그대로 유지됨
데이터 일관성을 보장하기 어려움

읽기 전용 작업: @Transactional(readOnly=true)
getUserGithubId(), getUserNickname()같은 조회 메소드에 적용하면 좋음
JPA가 영속성 컨텍스트를 flush하지 않아 성능 향상
실수로 데이터 수정되는 것 방지

추가 정보
- @Transactional은 해당 메소드와 그 안에서 호출되는 모든 메소드들을 하나의 트랜잭션으로 묶어줌
ex) saveOrLoginOAuth2User()에만 붙여도 그 안에서 호출되는 signUpOAuth2User() 메소드도 같은 트랜잭션 내에서 실행되어 각각 붙일 필요가 없음
- Spring AOP는 public 메소드에만 프록시를 생성하기 때문에 private 메소드에는 @Transactional을 붙여도 작동하지 않음

### 250123
책임 분리가 좀 모호해지더라도 service에서 token 정보를 불러와서 사용할까, controller에서 token 정보를 가져와 책임 분리를 지키고 임시저장을 이용할까?

service에서 token 정보를 불러와 사용하기로 했다. 임시 저장을 사용할 경우 동시성 문제가 발생할 수 있기 때문이다. 또, SecurityUtil이 이미 독립적인 유틸리티로 설계되어 있어 token 인증 관련 로직은 분리되어 있다고 생각한다. 서비스 계층이 보안 관련 로직과 독립적이면 좋겠지만 동시성 문제 해결을 위해 service에서 token의 usercode 정보를 불러오기로 했다.

느낀점
Spring security를 사용할 경우 token검증 뿐만 아니라 security에서 요청, 접근을 제한하여 검증 로직을 작성하는데 편리함을 느꼈습니다. 후에 프로젝트를 할 때도 security의 접근 권한 설정에 더 익숙해져야 겠습니다.

### 250124

오늘 협업을 하며 소통이 얼마나 중요한지 다시 한 번 느끼게 되었다. 여러 기능을 개발하고 오류를 잡으며 작업 내역이 점점 커지고 있는데, 한 번에 몰아서 커밋을 하면 어떤 작업을 개발하고 수정했는지 한눈에 확인하기가 어려웠다.

특히 오늘은 pull을 받아 작업하던 중, User 엔티티에 UUID 생성 로직을 추가한 부분이 공유되지 않아 문제가 발생했다. 이로 인해 서비스 계층에서 UUID를 생성하는 로직과 충돌하며 동시성 문제가 생겼다. 처음에는 지난번 임시 저장 코드 수정 과정에서 제대로 해결하지 못한 부분 때문이라고 생각해 다른 부분만 열심히 살펴보았다. 하지만 sysout으로 하나하나 출력해 확인하던 중 결국 User 엔티티에 문제가 있다는 것을 발견하게 되었다. 

문제 자체는 정말 간단한 부분이었지만, 이를 해결하기 위해 오랜 시간을 투자했어서 오류를 해결한 뒤에는 안도감보다는 심적으로 정말 지쳤었다. 그러나 이번 경험을 통해 코드 리뷰를 더 꼼꼼히 진행하고, 커밋을 최대한 잘게 나누는 습관을 들이기로 결심했다. 또, 수정 사항이 생기면 메모장에라도 바로 기록해 공유하는 습관을 만들어야겠다고 다짐했다.

오늘은 기술적인 부분보다는 협업에서의 소통과 관련된 중요한 경험을 적고 싶어 TIL에 작성하게 되었다.
